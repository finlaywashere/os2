bits 64
org 0x9000
_start:
	; Clear the screen
	mov rax, 0xB8000 ; Video memory
	mov rbx, 0
.loop:
	mov byte [rax], 0x0
	add rax, 2
	inc ebx
        cmp ebx, 4800
        jne .loop
	
	; Parse ELF stuff
	push rax
	push rbx
	push rcx
	push rdx
	mov rax, [0xd000]
	cmp al, 0x7F
	jne $
	cmp ah, 0x45
	jne $
	mov rax, [0xd002]
	cmp al, 0x4C
	jne $
	cmp ah, 0x46
	jne $
	
	; The kernel was successfully loaded!

	mov r13, 0x8000+511*8 ; P4 start
	mov r11, 0x1003
	mov [r13], r11
	mov r13, 0x11000 ; Paging physical start
	mov r11, 0x1000+510*8 ; P3 table
	mov r12, 0x2003
	mov [r11], r12 ; Map p2 table
	mov r11, 0x2000 ; P2 table
	mov r12, 0x10003
	mov [r11], r12 ; Map p1 table
	
	mov rcx, [0xd000+24] ; Put program entry point in rcx
	mov rbx, [0xd000+32] ; Put program header table position in rbx
	add rbx, 0xd000 ; Add memory offset to program header table
	
	mov r14b, [0xd000+56] ; Number of program header entries
	
	mov rdx, 0 ; Set counter to 0
	
.paging:
	mov rax, 0x1000
	push rdx
	mul rdx
	pop rdx
	add rax, 0x11000 ; Add physical offset
	or rax, 0b11
	mov [0x10000+rdx*8], rax
	inc rdx
	cmp rdx, 512
	jne .paging
	mov rdx, 0 ; Set counter to 0
	mov rax, 0 ; Clear rax
        mov al, [0xd000+54] ; Size of program header entries
.loop2:
	cmp rdx, r14
	jge .loop2end ; Check if the counter is too high and exit
	
	mov esi, [rbx]
	cmp esi, 1 ; Check if the segment type is loadable
	jne .loop2end2
	
	; It is a loadable segment
	mov r8, [rbx+8] ; Where the data is on disk
	add r8, 0xd000 ; Add memory offset
	mov r9, [rbx+16] ; Where the data needs to go
	mov r10, [rbx+32] ; Size of the segment
	mov r11, 0 ; Current memcpy count
	mov dil, 0 ; Check tmp register
.memcpy:
	mov dil, [r8] ; Copy data to register
	mov [r9], dil ; Copy register to memory
	inc r8
	inc r9
	inc r11
	cmp r11, r10
	jne .memcpy
	
	cmp rdx, rax
	jne .loop2end2
.loop2end2:
	inc rdx
	add rbx, rax
	jmp .loop2
.loop2end:
	jmp rcx
