bits 16

org 0x7C00
section .text

global _start
_start:
	mov esp, 0x7000 ; Set stack to be below our code so we've got a bit of space to store data from the BIOS
	push 0x6000
	push 0
	push 0
	push 0
	
	mov di, 0x6000 ; Memory map location
	mov ebx, 0 ; Clear ebx
	mov edx, 0x534D4150 ; Magic number
	mov eax, 0xE820
	mov ecx, 24
	int 0x15 ; Call BIOS for memory map
	
	; Setup page tables now to save trouble later
	mov edx, 0x8000
        mov ebx, 0x3003
        mov [edx], ebx ; Map p3 in p4 table
	mov edx, 0x3000
	mov ebx, 0x4003
	mov [edx], ebx ; Map p2 in p3 table
	mov edx, 0x4000
	mov ebx, 0x5003
	mov [edx], ebx ; Map p1 in p2 table
	mov ecx, 1
.loop:
	mov eax, 0x1000 ; 4KiB
	mul ecx
	or eax,0b11
	mov [0x5000 + ecx*8], eax ; map entry
	inc ecx
	cmp ecx, 512
	jne .loop
	
	; Load kernel from disk now so we can use the BIOS
	mov ah, 0x42 ; LBA Read command
	mov dl, 0x80 ; Use default drive
	mov si, disk_packet ; Set packet location
	int 0x13 ; Call BIOS
		
	cli ; Disable interrupts
	; Quickly set A20
	in al, 0x92
	or al, 2
	out 0x92, al
	
	; Load GDT
	xor eax, eax
	mov ax, ds
	shl eax, 4
	add eax, GDT
	mov [gdtr + 2], eax
	mov eax, GDT_end
	sub eax, GDT
	mov [gdtr], ax
	lgdt [gdtr]
	
	; Enter protected mode
	mov eax, cr0
	or al, 1
	mov cr0, eax
	
	jmp 08h:protectedMode
bits 32
protectedMode:
	mov ecx, 0x8000
	mov cr3, ecx
		
	; Enable PAE
        mov eax, cr4 ; Copy CR4 to eax
        or eax, 100000b ; Enable the PAE bit
        mov cr4, eax ; Move changes to CR4
	
	; Set long mode bit in MSR
        mov ecx, 0xC0000080
        rdmsr
        or eax, 1 << 8
        wrmsr
	
	; Enable paging
	mov eax, cr0
	or eax, 0x80000000
	mov cr0, eax
	
	; Load long mode GDT
        xor eax, eax
        mov ax, ds
        shl eax, 4
        add eax, GDT2
        mov [gdtr2 + 2], eax
        mov eax, GDT2_end
        sub eax, GDT2
        mov [gdtr2], ax
        lgdt [gdtr2]
	
	jmp 08h:longMode
bits 64
longMode:
	mov rax, 0x10
	mov ds, rax
	mov ss, rax
	mov es, rax
	mov fs, rax
	mov gs, rax
	jmp 0x9000
section .rodata
gdtr:
	dw 0
	dd 0
GDT:
	dq 0 ; null segment
	
	dw 0xFFFF ; Code limit
	dw 0 ; Code base low
	db 0 ; Code base mid
	db 10011000b ; Code access
	db 11001111b ; Code flags
	db 0 ; Code base high

	dw 0xFFFF ; Data limit
        dw 0 ; Data base low
        db 0 ; Data base mid
        db 10010010b ; Data access
        db 10001111b ; Data flags
        db 0 ; Data base high
GDT_end:
gdtr2:
        dw 0
        dd 0
GDT2:
        dq 0 ; null segment

        dw 0xFFFF ; Code limit
        dw 0 ; Code base low
        db 0 ; Code base mid
        db 10011000b ; Code access
        db 10101111b ; Code flags
        db 0 ; Code base high

        dw 0xFFFF ; Data limit
        dw 0 ; Data base low
        db 0 ; Data base mid
        db 10010010b ; Data access
        db 10001111b ; Data flags
        db 0 ; Data base high

GDT2_end:
align 32 ; Packet must be on 4 byte boundary
disk_packet:
	db 16 ; Size of packet
	db 0 ; Zero
	dw 64 ; Number of sectors
	dw 0x9000 ; Buffer offset
	dw 0 ; Buffer segment
	dd 1 ; Lower 32 bits of starting LBA
	dd 0 ; Upper 32 bits of starting LBA
boot_header:
	resb 110
	db 0x55
	db 0xAA
